const v3 = twgl.v3;

class Object3{
	position = v3.create(0,0,0);
	rotation = v3.create(0,0,0);
	scaling = v3.create(1,1,1);

	children = [];
	parent = null;
	name = null;
	animationPlayer = null;
	renderVisibility = true;

	constructor({position = null, rotation = null, scaling = null, name = null}={}){	//	Initialize the object's properties if custom values were given
		if(position){
			this.position[0] = position[0] || this.position[0];
			this.position[1] = position[1] || this.position[1];
			this.position[2] = position[2] || this.position[2];
		}
		if(rotation){
			this.rotation[0] = rotation[0] || this.rotation[0];
			this.rotation[1] = rotation[1] || this.rotation[1];
			this.rotation[2] = rotation[2] || this.rotation[2];
		}
		if(scaling){
			this.scaling[0] = scaling[0] || this.scaling[0];
			this.scaling[1] = scaling[1] || this.scaling[1];
			this.scaling[2] = scaling[2] || this.scaling[2];
		}
		this.name = name;
	}

	appendChild(child){	//	Adds given object as this object's child. Makes sure the object only has one parent (this one)
		if(child instanceof Object3){
			if(child.parent) child.parent.removeChild(child);
			child.parent = this;
			this.children.push(child);
			if(child.onChildAdded) child.onChildAdded(this);
		}
	}

	removeChild(child) {	//	Removes child object
		if(child instanceof Object3){
			child.parent = null;
			if(child.onChildRemoved) child.onChildRemoved(this);
		}
		for(let i=0; i<this.children.length; i++){
			if(this.children[i] === child){
				let popped = this.children.pop();	//	Array.splice is slower because it tries to preserve the order of the array, while this method simply removes the object and replaces it with the last object in the list
				if(i !== this.children.length) {
					this.children[i] = popped;
				}
				return;
			}
		}
	}
	getChildWithName(name){	//	Find an object which is a direct child of this one with the given name
		return this.children.find((c)=>(c.name == name));
	}
	getAnyChildWithName(name){	//	Find an object which is a child of this one with the given name. Checks for children of children recursively as well.
		let childDepth = Infinity;
		function getChildByNameRec(obj, depth){
			let result = obj.getChildWithName(name);
			if(result) {
				childDepth = depth;
				return result;
			}
			if(childDepth > depth){
				for(let child of obj.children){
					result = getChildByNameRec(child, depth + 1);
					if(result) return result;
				}
			}
			return null;
		}
		return getChildByNameRec(this, 0);
	}
	calculateMatrix(parent, adjustment){	//	Calculate the model transform matrix for this object. parent is the model transform matrix of the parent object, and adjustment is the transformation generated by animations
		if(!adjustment) adjustment = {};
		let matrix = m4.identity();
		let vector = v3.copy(this.position);
		if(adjustment.position){
			vector[0] += adjustment.position[0];
			vector[1] += adjustment.position[1];
			vector[2] += adjustment.position[2];
		}
		m4.translate(matrix, vector, matrix);

		v3.copy(this.rotation, vector);
		vector[0] *= (Math.PI/180);
		vector[1] *= (Math.PI/180);
		vector[2] *= (Math.PI/180);

		m4.rotateZ(matrix, vector[2], matrix);
		m4.rotateY(matrix, vector[1], matrix);
		m4.rotateX(matrix, vector[0], matrix);

		if(adjustment.rotation){
			m4.multiply(matrix,adjustment.rotation,matrix);
		}

		v3.copy(this.scaling, vector);
		if(adjustment.scale){
			vector[0] *= adjustment.scale[0];
			vector[1] *= adjustment.scale[1];
			vector[2] *= adjustment.scale[2];
		}
		m4.scale(matrix, vector, matrix);
		m4.multiply(parent, matrix, matrix);
		return matrix;
	}
	playAnimation(name, params){	//	Shorthand for animationPlayer.play()
		if(this.animationPlayer) this.animationPlayer.play(name,params);
	}
}